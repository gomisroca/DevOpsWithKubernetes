# Introduction to Google Kubernetes Engine

We will now move from a local cluster to a GKE cluster. We will need to install the Google Cloud SDK, and create a cluster with `gcloud container clusters create <cluster-name> --zone=<zone> --cluster-version=<cluster-version> --disk-size=<disk-size> --num-nodes=<num-nodes> --machine-type=<machine-type>`. We need to enable the Kubernetes Engine API for our project, which can be done with `gcloud services enable container.googleapis.com`.

After creating the cluster, we can use `kubectl cluster-info` to see the information about the cluster. If it is not yet pointing to the GKE cluster, we can set it with `gcloud container clusters get-credentials <cluster-name> --zone=<zone>`.

### Deploying to GKE

Now we can deploy to the GKE cluster just like we did locally: `kubectl apply -f <file>`.

Exposing the service is where the differences start to show. We need a LoadBalancer instead of an Ingress:

```yaml
apiVersion: v1
kind: Service
metadata:
  name: seedimage-svc
spec:
  type: LoadBalancer
  selector:
    app: seedimage
  ports:
    - port: 80
      protocol: TCP
      targetPort: 3000
```

After it is ready, we will be able to access our application from the external IP of the LoadBalancer.

To avoid unexpected costs, we should delete the cluster after we are done with it: `gcloud container clusters delete <cluster-name> --zone=<zone>`.

### Persisting data in GKE

GKE automatically provisions a persistent disk for our PersistentVolumeClaims. We just don't set the storage class.

### From Service to Ingress

Services allow us to define a layer 4 (L4) load balancer, which handles TCP/UDP traffic. For advanced traffic rules, we need a L7, created by Ingress or Gateway resources. For now, we will use Ingress:

Coming from the previous example, we will modify the `service.yaml` file to look like this:

```yaml
apiVersion: v1
kind: Service
metadata:
  name: seedimage-svc
spec:
  type: NodePort
  selector:
    app: seedimage
  ports:
    - port: 80
      protocol: TCP
      targetPort: 3000
```

Then, the `ingress.yaml` file will look like this:

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: seedimage-ing
spec:
  rules:
    - http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: seedimage-svc
                port:
                  number: 80
```

Now if we run `kubectl get ing` we will see the Ingress and its address, which we can use to access the application.

### Gateway API

The Gateway API is a new next-generation solution for routing replacing the Ingress resource. It is a set of resources and standards that let us define how external traffic should be routed to services within our cluster. To use it, we need to enable it with `gcloud container clusters update <cluster-name> --location=<zone> --gateway-api=standard`.

The Gateway API has several parts to it:

The `GatewayClass` resource defines the type of gateway that will be used. It defines the underlying structure.

The `Gateway` defines where and how the load balancers listen for traffic. We will create a `gateway.yaml` to configure the Gateway:

```yaml
apiVersion: gateway.networking.k8s.io/v1beta1
kind: Gateway
metadata:
  name: my-gateway
spec:
  gatewayClassName: gke-l7-global-external-managed
  listeners:
    - name: http
      protocol: HTTP
      port: 80
      allowedRoutes:
        kinds:
          - kind: HTTPRoute
```

It is a simple file: it uses a gatewayClassName from the Google recommendations, and says our cluster accepts HTTP traffic on port 80.

The `HTTPRoute` resource defines the rules for the traffic. We will create a `route.yaml` file:

```yaml
apiVersion: gateway.networking.k8s.io/v1beta1
kind: HTTPRoute
metadata:
  name: my-route
spec:
  parentRefs:
    - name: my-gateway
  rules:
    - matches:
        - path:
            type: PathPrefix
            value: /
      backendRefs:
        - name: seedimage-svc
          port: 80
```

Very similar to the Ingress files.

Finally, we will need to change the Service port type to `ClusterIP`:

```yaml
apiVersion: v1
kind: Service
metadata:
  name: seedimage-svc
spec:
  type: ClusterIP
  selector:
    app: seedimage
  ports:
    - port: 80
      protocol: TCP
      targetPort: 3000
```

Now, we can use `kubectl get gateway my-gateway` to see the Gateway and its address, which we can use to access the application.
