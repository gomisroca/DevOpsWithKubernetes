# Custom Resource Definitions

CRDs are a way to extend Kubernetes with our own resources. We've already used some, like ArgoCD's Application.

Let's create a Countdown resource, which will be used to create countdowns.

resourcedefinition.yaml:

```yaml
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  # name must match the spec fields below, and be in the form: <plural>.<group>
  name: countdowns.stable.dwk
spec:
  # group name to use for REST API: /apis/<group>/<version>
  group: stable.dwk
  # either Namespaced or Cluster
  scope: Namespaced
  names:
    # kind is normally the CamelCased singular type. Your resource manifests use this.
    kind: Countdown
    # plural name to be used in the URL: /apis/<group>/<version>/<plural>
    plural: countdowns
    # singular name to be used as an alias on the CLI and for display
    singular: countdown
    # shortNames allow shorter string to match your resource on the CLI
    shortNames:
      - cd
  # list of versions supported by this CustomResourceDefinition
  versions:
    - name: v1
      # Each version can be enabled/disabled by Served flag.
      served: <strong>true</strong>
      # One and only one version must be marked as the storage version.
      storage: <strong>true</strong>
      schema:
        openAPIV3Schema:
          type: object
          properties:
            spec:
              type: object
              properties:
                length:
                  type: integer
                delay:
                  type: integer
                image:
                  type: string
      additionalPrinterColumns:
        - name: Length
          type: integer
          description: The length of the countdown
          jsonPath: .spec.length
        - name: Delay
          type: integer
          description: The length of time (ms) between executions
          jsonPath: .spec.delay
```

Now we can define our own Countdown in countdown.yaml:

```yaml
apiVersion: stable.dwk/v1
kind: Countdown
metadata:
  name: doomsday
spec:
  length: 20
  delay: 1200
  image: jakousa/dwk-app10:sha-84d581d
```

And finally: `kubectl apply -f countdown.yaml` `kubectl get cd`

Now, we need a custom controller that will start a pod that runs a container from the image and makes sure countdowns are destroyed. We will use a Job. Pods created by Jobs are intended to run once until completion, but they are not automatically deleted.

Our controller has to do 3 things:

- Create a Job from a Countdown
- Reschedule Jobs until the number of executions defined in the Countdown (the length) is reached
- Clean all Jobs and Pods after the execution

By listening to the k8s API at `/apis/stable.dwk/v1/countdowns?watch=true` we will receive an ADDED for every Countdown obj in the cluster. Creating a Job can then be done by parsing the data from that msg and POSTing a valid payload to `/apis/batch/v1/namespaces/<namespace>/jobs`.

For Jobs, we will listen to `/apis/batch/v1/jobs?watch=true` and wait for MODIFIED events where the success state is set to true. To delete a Job and its Pod, we will send a DELETE request to `/api/v1/namespaces/<namespace>/pods/<pod_name>` and `/apis/batch/v1/namespaces/<namespace>/jobs/<job_name>`. Lastly, we will delete the Countdown with a DELETE request to `/apis/stable.dwk/v1/namespaces/<namespace>/countdowns/<countdown_name>`.

However, we can't just deploy the controller, as it won't have access to the APIs. For this, we need to define suitable access.

### RBAC

RBAC (Role-Based Access Control) is a way to define access to resources in Kubernetes.

For our case, we want to define a ServiceAccount in serviceaccount.yaml:

```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: countdown-controller-account
```

Then we can specify the serviceAccountName in the Deployment:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: countdown-controller-dep
spec:
  replicas: 1
  selector:
    matchLabels:
      app: countdown-controller
  template:
    metadata:
      labels:
        app: countdown-controller
    spec:
      serviceAccountName: countdown-controller-account
      containers:
        - name: countdown-controller
          image: jakousa/dwk-app10-controller:sha-4256579
```

There are two types of roles: ClusterRole and Role. ClusterRoles are meant to be used by the cluster itself, while Roles are meant to be used by a specific namespace.

The rules are defined by the apiGroup, resource, and verb. For example, `/apis/batch/v1/jobs?watch=true` is in the apiGroup `batch`, the resource `jobs`, and the verb `watch`. The file clusterrole.yaml will look like this:

```yaml
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: countdown-controller-role
rules:
  - apiGroups: [""] # Core API group
    # at the HTTP level, the name of the resource for accessing Pod
    # objects is "pods"
    resources: ["pods"]
    verbs: ["get", "list", "delete"]
  - apiGroups: ["batch"]
    # at the HTTP level, the name of the resource for accessing Job
    # objects is "jobs"
    resources: ["jobs"]
    verbs: ["get", "list", "watch", "create", "delete"]
  - apiGroups: ["stable.dwk"]
    resources: ["countdowns"]
    verbs: ["get", "list", "watch", "create", "delete"]
```

Lastly, we need to bind the ServiceAccount and the role. Since we're using a ClusterRole, we can do this in clusterrolebinding.yaml:

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: countdown-rolebinding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: countdown-controller-role
subjects:
  - kind: ServiceAccount
    name: countdown-controller-account
    namespace: default
```
